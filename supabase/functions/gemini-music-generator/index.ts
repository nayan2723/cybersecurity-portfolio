import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY');

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { mood, language = 'both' } = await req.json();

    if (!mood) {
      throw new Error('Mood is required');
    }

    if (!GEMINI_API_KEY) {
      throw new Error('Gemini API key is not configured');
    }

    console.log(`Generating songs for mood: ${mood}, language: ${language}`);

    // Create a detailed prompt for Gemini to generate song recommendations
    const prompt = `You are a music expert and DJ. Generate 4 song recommendations based on the mood "${mood}" for someone who is a programmer/developer. 

Requirements:
- ${language === 'english' ? 'Provide only English songs' : language === 'hindi' ? 'Provide only Hindi/Bollywood songs' : 'Provide 2 English and 2 Hindi/Bollywood songs'}
- Include popular and well-known songs that match the "${mood}" mood
- Format each song as: "ðŸŽµ Song Title - Artist Name" or "ðŸŽ¶ Song Title - Artist Name" 
- Make sure the songs actually exist and are real songs
- Choose songs that would resonate with programmers/developers
- Consider the emotional state implied by "${mood}" mood
- Mix classic and modern songs

Return only the 4 song recommendations, one per line, nothing else.`;

    // Make request to Gemini API
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.8,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 1024,
        },
        safetySettings: [
          {
            category: "HARM_CATEGORY_HARASSMENT",
            threshold: "BLOCK_MEDIUM_AND_ABOVE"
          },
          {
            category: "HARM_CATEGORY_HATE_SPEECH",
            threshold: "BLOCK_MEDIUM_AND_ABOVE"
          },
          {
            category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            threshold: "BLOCK_MEDIUM_AND_ABOVE"
          },
          {
            category: "HARM_CATEGORY_DANGEROUS_CONTENT",
            threshold: "BLOCK_MEDIUM_AND_ABOVE"
          }
        ]
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Gemini API error:', errorText);
      throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    console.log('Gemini response:', JSON.stringify(data, null, 2));

    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
      throw new Error('No content generated by Gemini');
    }

    const generatedText = data.candidates[0].content.parts[0].text;
    console.log('Generated songs:', generatedText);

    // Parse the generated songs
    const songs = generatedText
      .split('\n')
      .filter((line: string) => line.trim() && (line.includes('ðŸŽµ') || line.includes('ðŸŽ¶')))
      .map((line: string) => line.trim())
      .slice(0, 4); // Ensure we only get 4 songs

    // Fallback songs if parsing fails or not enough songs generated
    const fallbackSongs = {
      happy: [
        'ðŸŽµ Happy - Pharrell Williams',
        'ðŸŽ¶ à¤–à¥à¤¶à¤¿à¤¯à¥‹à¤‚ à¤•à¤¾ à¤—à¥€à¤¤ - Lata Mangeshkar',
        'ðŸŽµ Good as Hell - Lizzo',
        'ðŸŽ¶ Zindagi Ek Safar - Kishore Kumar'
      ],
      tired: [
        'ðŸŽµ Tired - Alan Walker',
        'ðŸŽ¶ à¤¸à¥à¤¨ à¤°à¥‡ à¤ªà¤—à¤²à¥€ - Lata Mangeshkar',
        'ðŸŽµ Heavy - Linkin Park',
        'ðŸŽ¶ à¤šà¤² à¤—à¥à¤œà¤¾à¤°à¤¾ - Kishore Kumar'
      ],
      debugging: [
        'ðŸŽµ Fix You - Coldplay',
        'ðŸŽ¶ à¤•à¥à¤› à¤¤à¥‹ à¤—à¤¡à¤¼à¤¬à¤¡à¤¼ à¤¹à¥ˆ - Shankar Mahadevan',
        'ðŸŽµ Help! - The Beatles',
        'ðŸŽ¶ à¤¸à¤®à¤¸à¥à¤¯à¤¾ à¤•à¤¾ à¤¸à¤®à¤¾à¤§à¤¾à¤¨ - Rahat Fateh Ali Khan'
      ]
    };

    // Use generated songs if we have enough, otherwise use fallback
    let finalSongs = songs.length >= 2 ? songs : (fallbackSongs[mood as keyof typeof fallbackSongs] || fallbackSongs.happy);

    return new Response(JSON.stringify({ 
      songs: finalSongs,
      mood,
      source: songs.length >= 2 ? 'gemini' : 'fallback'
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (error) {
    const err = error instanceof Error ? error : new Error('Unknown error');
    console.error('Error in gemini-music-generator function:', err);
    
    // Return fallback songs on error
    const fallbackSongs = [
      'ðŸŽµ Code Monkey - Jonathan Coulton',
      'ðŸŽ¶ à¤¡à¤¿à¤œà¤¿à¤Ÿà¤² à¤‡à¤‚à¤¡à¤¿à¤¯à¤¾ - A.R. Rahman',
      'ðŸŽµ Technologic - Daft Punk',
      'ðŸŽ¶ à¤•à¥‰à¤«à¥€ à¤ªà¥€à¤•à¥‡ - Arijit Singh'
    ];

    return new Response(JSON.stringify({ 
      songs: fallbackSongs,
      error: err.message,
      source: 'fallback'
    }), {
      status: 200, // Return 200 with fallback to keep UI working
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});